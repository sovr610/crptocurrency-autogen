// Generated by CoffeeScript 2.1.1
(function() {
  var DEFAULT_MSG, colors, extend, path, template, through;

  colors = require('ansi-colors');

  through = require('through2');

  extend = require('xtend');

  path = require('path');

  template = require('lodash.template');

  DEFAULT_MSG = '<%= files %>';

  /*
  Count files in stream and log message when stream ends. Only counts *files*, ignores directories and
  other types of stream contents. Supports buffer and stream contents. Passes files through unchanged.
  Message is passed through `template` to allow for custom formatting. Also supports custom
  logging (but defaults to `console.log`).

  @param message [String] optional message format (see options)
  @param options [Object] options object
  @option options [String] message message format string (default: `'## files'`). template has two
    variables: `counter` - the number of files processed, and `files` - string of the format
    `X file[s]` where X is `counter` and 'files' is pluralized if necessary. the symbol `'##'`
    is expanded internally to `<%= counter %>`. an explicit `false` value disables logging a message
    when the stream ends.
  @option options [String] title string prepended to every message `"[title]: [message]"`
  @option options [Boolean|String] logFiles whether to log each file path as it is counted. if a
    string is provided then it is used as the message template. template has two variables: `file` -
    vinyl file instance, and `path` - file path resolved relative to `cwd` and colored yellow.
    (default: `false`)
  @option options [String] cwd directory for logging relative file paths (default: `''`)
  @option options [Function] logger function to call with formatted message (default: `console.log`)
  @option options [Boolean|String] logEmpty whether to log empty streams (no files). if a
    string is provided then it is used as the message template. (default: `false`)
  @example
    gulp.src('*.html')
      .pipe count() # logs '36 files'
      .pipe count('found ## pages') # logs 'found 36 pages'
      .pipe count('<%= counter %> HTML files')  # logs '36 HTML files'
      .pipe count
        message: '<%= files %>? That\'s ## too many!'
        logger: (msg) -> alert(msg) # alerts "36 files? That's 36 too many!"
  */
  module.exports = function(message, options = {}) {
    var counter, increment, log, logCount;
    // message argument is optional
    if (typeof message === 'object') {
      options = message;
      message = void 0;
    }
    // default options
    options = extend({
      cwd: '',
      title: null,
      logger: console.log,
      message: message != null ? message : DEFAULT_MSG,
      logEmpty: false
    }, options);
    if (options.message === true) {
      options.message = DEFAULT_MSG;
    }
    counter = 0;
    log = function(msg) {
      if (options.title) {
        msg = options.title + ": " + msg;
      }
      return options.logger(msg);
    };
    // transform: increment counter for every file
    increment = function(file, enc, cb) {
      var filepath;
      counter++;
      if (options.logFiles) {
        filepath = colors.yellow(path.relative(options.cwd, file.path));
        if (typeof options.logFiles === 'string') {
          log(template(options.logFiles)({
            path: filepath,
            file: file
          }));
        } else {
          log(filepath);
        }
      }
      return cb(null, file);
    };
    // flush: log message when stream ends
    logCount = function(cb) {
      var counterStr, filesStr;
      counterStr = colors.magenta(counter);
      filesStr = `${counterStr} file${(counter !== 1 ? 's' : '')}`;
      if (counter === 0 && options.logEmpty) {
        message = typeof options.logEmpty === 'string' ? options.logEmpty : DEFAULT_MSG;
        log(template(message)({
          files: filesStr,
          counter: counterStr,
          file: null
        }));
      } else if (counter > 0 && typeof options.message === 'string') {
        message = options.message.replace('##', '<%= counter %>');
        log(template(message)({
          files: filesStr,
          counter: counterStr,
          file: null
        }));
      }
      return cb();
    };
    return through.obj(increment, logCount);
  };

}).call(this);
